# Realization of DPWM

## introduction
1. 9bit Counter-based DPWM
2. 9bit Hybrid DPWM
3. 9bit Dither DPWM
4. 9bit Dither DPWM with dead-time
Note: the DPWM will be implemented in Verilog

## Realize process 
1. 9bit Counter-based DPWM
  - Constructed with a counter, two comparators, and an SR latch

![C](./figure/1.jfif)

2. 9bit Hybrid DPWM
  - Implemented using a combination of a 6-bit DPWM and a 3-bit delay line

![C](./figure/2.jfif)

3. 9bit Dither DPWM
  - An excessively high operating frequency leads to significant dynamic power consumption. By introducing the concept of dithering, the operating frequency can be reduced—requiring only 64 MHz—thus greatly lowering dynamic power consumption. With dithering, the DPWM can approximate high-resolution performance under steady-state conditions.
  - Top Module: The duty signal generated by the compensator is first passed through the dithering system, where the upper 6 bits are extracted during each cycle. After processing, the result is formatted into a 6-bit input.
  - Clock (Clk): The input clock frequency is divided by a counter to achieve the required 1 MHz frequency for the Dither module. The logic is implemented in Verilog to toggle the clock signal and reset the counter once it reaches the specified threshold. This enables proper timing for the Counter DPWM processing.

![C](./figure/3.jfif)

4. 9bit Dither DPWM with dead-time
  - A counter is used to track clock cycles and generate duty-cycle signals by comparing its value against predefined thresholds for the high and low states. Two comparators (duty_high and duty_low) are implemented to control the PWM outputs, while a dead-time mechanism is introduced to ensure that the two signals do not overlap.

![C](./figure/3.jfif)
